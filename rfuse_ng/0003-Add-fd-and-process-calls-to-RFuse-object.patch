From 50e7f24b4933ecf917b8c7137a61cf6d565b5331 Mon Sep 17 00:00:00 2001
From: Grant Gardner <grant@lastweekend.com.au>
Date: Sat, 12 Feb 2011 16:28:12 +1100
Subject: [PATCH 3/3] Add fd and process calls to RFuse object

---
 ext/intern_rfuse.c |   35 ++++++++++++++++++++++++++++++++---
 ext/intern_rfuse.h |    3 +++
 ext/rfuse.c        |   21 +++++++++++++++++++++
 3 files changed, 56 insertions(+), 3 deletions(-)

diff --git a/ext/intern_rfuse.c b/ext/intern_rfuse.c
index 09b9a5a..f6fb740 100644
--- a/ext/intern_rfuse.c
+++ b/ext/intern_rfuse.c
@@ -1,8 +1,7 @@
+#include "intern_rfuse.h"
+#include <fuse/fuse_lowlevel.h>
 #include <stdlib.h>
 #include <string.h>
-#include <fuse.h>
-#include "intern_rfuse.h"
-
 struct intern_fuse *intern_fuse_new() {
   struct intern_fuse *inf;
   inf = (struct intern_fuse *) malloc(sizeof(struct intern_fuse));
@@ -41,3 +40,33 @@ int intern_fuse_init(
   strncpy(inf->mountname, mountpoint, MOUNTNAME_MAX);
   return 0;
 };
+
+// Return the /dev/fuse file descriptor for use with IO.select
+int intern_fuse_fd(struct intern_fuse *inf) {
+  if (inf->fc == NULL) {
+    return -1;
+  }
+  struct fuse_chan *fc = inf->fc;
+  return fuse_chan_fd(fc);
+}
+
+//Process one fuse command (ie after IO.select)
+int intern_fuse_process(struct intern_fuse *inf) {
+  if (inf->fuse == NULL) {
+     return -1;
+  }
+
+
+  if (fuse_exited(inf->fuse)) {
+     return -1;
+  }
+
+  struct fuse_cmd *cmd;
+  cmd = fuse_read_cmd(inf->fuse);
+  if (cmd != NULL) {
+    fuse_process_cmd(inf->fuse, cmd);
+  }
+  return 0;
+}
+
+
diff --git a/ext/intern_rfuse.h b/ext/intern_rfuse.h
index e630869..0ff4b06 100644
--- a/ext/intern_rfuse.h
+++ b/ext/intern_rfuse.h
@@ -20,4 +20,7 @@ int intern_fuse_init(
   struct fuse_args *libopts
 );
 
+int intern_fuse_fd(struct intern_fuse *inf);
+int intern_fuse_process(struct intern_fuse *inf);
+
 int intern_fuse_destroy(struct intern_fuse *inf);
diff --git a/ext/rfuse.c b/ext/rfuse.c
index 1780a57..d04be4d 100644
--- a/ext/rfuse.c
+++ b/ext/rfuse.c
@@ -1534,6 +1534,25 @@ VALUE rf_invalidate(VALUE self,VALUE path)
   return fuse_invalidate(inf->fuse,STR2CSTR(path)); //TODO: check if str?
 }
 
+//---------------------- fd
+// Return /dev/fuse file descriptor for use with IO.select
+VALUE rf_fd(VALUE self)
+{
+  struct intern_fuse *inf;
+  Data_Get_Struct(self,struct intern_fuse,inf);
+  return INT2NUM(intern_fuse_fd(inf));
+}
+
+//--------------------- process
+// Process one fuse command from the kernel
+// returns < 0 if we're not mounted.. won't be this simple in a mt scenario
+VALUE rf_process(VALUE self)
+{
+  struct intern_fuse *inf;
+  Data_Get_Struct(self,struct intern_fuse,inf);
+  return INT2NUM(intern_fuse_process(inf));
+}
+
 #define RESPOND_TO(obj,methodname) \
   rb_funcall( \
     obj,rb_intern("respond_to?"), \
@@ -1669,6 +1688,8 @@ VALUE rfuse_init(VALUE module)
   rb_define_method(cFuse,"invalidate",rf_invalidate,1);
   rb_define_method(cFuse,"unmount",rf_unmount,0);
   rb_define_method(cFuse,"mountname",rf_mountname,0);
+  rb_define_method(cFuse,"fd",rf_fd,0);
+  rb_define_method(cFuse,"process",rf_process,0);
 
   return cFuse;
 }
-- 
1.7.1

